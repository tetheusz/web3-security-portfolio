// test/ExploitBank.t.sol
// SPDX-License-identifier: MIT
pragma solidity ^0.8.30;

import "forge-std/Test.sol";
import "../src/SimpleBankVulnerable.sol";
import "../src/Attacker.sol";

contract ExploitBankTest is Test {
    SimpleBankVulnerable public bank;
    Attacker public attacker;

    // Constants
    uint256 constant INITIAL_VICTIM_DEPOSIT = 10 ether;
    uint256 constant ATTACKER_INITIAL_DEPOSIT = 1 ether;

    // Address for the "Victim" (simulated TVL provider)
    address internal constant VICTIM = address(0xBEEF); 

    function setUp() public {
        // 1. Deploy the SimpleBankVulnerable
        bank = new SimpleBankVulnerable();
        
        // 2. Victim deposits funds
        vm.deal(VICTIM, INITIAL_VICTIM_DEPOSIT); 
        vm.prank(VICTIM);
        bank.deposit{value: INITIAL_VICTIM_DEPOSIT}();
        
        // 3. Deploy and fund the Attacker (CONSTRUCTOR IS PAYABLE)
        attacker = new Attacker{value: ATTACKER_INITIAL_DEPOSIT}(address(bank)); 
        
        // 4. The Attacker deposits their 1 ether into the bank 
        vm.prank(address(attacker));
        attacker.deposit{value: ATTACKER_INITIAL_DEPOSIT}();
    }

    function testExploitReentrancy() public {
        // Total Bank balance: 11 ether
        uint256 initialBankBalance = address(bank).balance;
        
        // Initial Attacker contract balance (1 ether)
        uint256 initialAttackerContractBalance = attacker.checkBalance();

        console.log("---ATTEMPTED REENTRANCY ATTACK START---");
        vm.startPrank(address(attacker));
        // Call the secured function
        attacker.attackSecured(); 
        vm.stopPrank();
        console.log("---ATTEMPTED REENTRANCY ATTACK END---");

        // Final balance of the Attacker contract
        uint256 finalAttackerContractBalance = attacker.checkBalance();
        
        // 5. VERIFY RESULTS (The test should pass, proving the defense works)
        
        // The Attacker should have only withdrawn their 1 ether from the first call.
        // Expected final balance = Initial Attacker Contract Balance + 1 ether (the successful withdrawal)
        uint256 expectedFinalAttackerBalance = initialAttackerContractBalance + attacker.REENTRANCY_WITHDRAW_AMOUNT();        
        // ASSERT: Check that the Attacker was NOT able to drain extra funds.
        assertEq(finalAttackerContractBalance, expectedFinalAttackerBalance, "Attack Failed: Attacker balance is incorrect, defense may not be working.");

        // ASSERT: The bank should have only lost 1 ether from the single successful call.
        uint256 expectedRemainingBankBalance = initialBankBalance - attacker.REENTRANCY_WITHDRAW_AMOUNT();
        assertEq(address(bank).balance, expectedRemainingBankBalance, "Bank balance was drained incorrectly.");
        
        // Log
        console.log("Initial Attacker Contract Balance:", initialAttackerContractBalance);
        console.log("Final Attacker Contract Balance:", finalAttackerContractBalance);
        console.log("Final Bank Balance:", address(bank).balance);
    }
}